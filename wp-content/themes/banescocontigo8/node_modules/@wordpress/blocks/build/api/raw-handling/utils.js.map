{"version":3,"sources":["@wordpress/blocks/src/api/raw-handling/utils.js"],"names":["getBlockContentSchemaFromTransforms","transforms","context","phrasingContentSchema","schemaArgs","isPaste","schemas","map","isMatch","blockName","schema","hasAnchorSupport","Object","fromEntries","entries","key","value","attributes","undefined","objValue","srcValue","getBlockContentSchema","isPlain","HTML","test","deepFilterNodeList","nodeList","filters","doc","Array","from","forEach","node","childNodes","item","contains","deepFilterHTML","document","implementation","createHTMLDocument","body","innerHTML","getSibling","which","sibling","parentNode"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { mergeWith } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { isPhrasingContent, getPhrasingContentSchema } from '@wordpress/dom';\n\n/**\n * Internal dependencies\n */\nimport { hasBlockSupport } from '..';\nimport { getRawTransforms } from './get-raw-transforms';\n\nexport function getBlockContentSchemaFromTransforms( transforms, context ) {\n\tconst phrasingContentSchema = getPhrasingContentSchema( context );\n\tconst schemaArgs = { phrasingContentSchema, isPaste: context === 'paste' };\n\tconst schemas = transforms.map( ( { isMatch, blockName, schema } ) => {\n\t\tconst hasAnchorSupport = hasBlockSupport( blockName, 'anchor' );\n\n\t\tschema = typeof schema === 'function' ? schema( schemaArgs ) : schema;\n\n\t\t// If the block does not has anchor support and the transform does not\n\t\t// provides an isMatch we can return the schema right away.\n\t\tif ( ! hasAnchorSupport && ! isMatch ) {\n\t\t\treturn schema;\n\t\t}\n\n\t\tif ( ! schema ) {\n\t\t\treturn {};\n\t\t}\n\n\t\treturn Object.fromEntries(\n\t\t\tObject.entries( schema ).map( ( [ key, value ] ) => {\n\t\t\t\tlet attributes = value.attributes || [];\n\t\t\t\t// If the block supports the \"anchor\" functionality, it needs to keep its ID attribute.\n\t\t\t\tif ( hasAnchorSupport ) {\n\t\t\t\t\tattributes = [ ...attributes, 'id' ];\n\t\t\t\t}\n\t\t\t\treturn [\n\t\t\t\t\tkey,\n\t\t\t\t\t{\n\t\t\t\t\t\t...value,\n\t\t\t\t\t\tattributes,\n\t\t\t\t\t\tisMatch: isMatch ? isMatch : undefined,\n\t\t\t\t\t},\n\t\t\t\t];\n\t\t\t} )\n\t\t);\n\t} );\n\n\treturn mergeWith( {}, ...schemas, ( objValue, srcValue, key ) => {\n\t\tswitch ( key ) {\n\t\t\tcase 'children': {\n\t\t\t\tif ( objValue === '*' || srcValue === '*' ) {\n\t\t\t\t\treturn '*';\n\t\t\t\t}\n\n\t\t\t\treturn { ...objValue, ...srcValue };\n\t\t\t}\n\t\t\tcase 'attributes':\n\t\t\tcase 'require': {\n\t\t\t\treturn [ ...( objValue || [] ), ...( srcValue || [] ) ];\n\t\t\t}\n\t\t\tcase 'isMatch': {\n\t\t\t\t// If one of the values being merge is undefined (matches everything),\n\t\t\t\t// the result of the merge will be undefined.\n\t\t\t\tif ( ! objValue || ! srcValue ) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\t// When merging two isMatch functions, the result is a new function\n\t\t\t\t// that returns if one of the source functions returns true.\n\t\t\t\treturn ( ...args ) => {\n\t\t\t\t\treturn objValue( ...args ) || srcValue( ...args );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t} );\n}\n\n/**\n * Gets the block content schema, which is extracted and merged from all\n * registered blocks with raw transfroms.\n *\n * @param {string} context Set to \"paste\" when in paste context, where the\n *                         schema is more strict.\n *\n * @return {Object} A complete block content schema.\n */\nexport function getBlockContentSchema( context ) {\n\treturn getBlockContentSchemaFromTransforms( getRawTransforms(), context );\n}\n\n/**\n * Checks whether HTML can be considered plain text. That is, it does not contain\n * any elements that are not line breaks.\n *\n * @param {string} HTML The HTML to check.\n *\n * @return {boolean} Whether the HTML can be considered plain text.\n */\nexport function isPlain( HTML ) {\n\treturn ! /<(?!br[ />])/i.test( HTML );\n}\n\n/**\n * Given node filters, deeply filters and mutates a NodeList.\n *\n * @param {NodeList} nodeList The nodeList to filter.\n * @param {Array}    filters  An array of functions that can mutate with the provided node.\n * @param {Document} doc      The document of the nodeList.\n * @param {Object}   schema   The schema to use.\n */\nexport function deepFilterNodeList( nodeList, filters, doc, schema ) {\n\tArray.from( nodeList ).forEach( ( node ) => {\n\t\tdeepFilterNodeList( node.childNodes, filters, doc, schema );\n\n\t\tfilters.forEach( ( item ) => {\n\t\t\t// Make sure the node is still attached to the document.\n\t\t\tif ( ! doc.contains( node ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\titem( node, doc, schema );\n\t\t} );\n\t} );\n}\n\n/**\n * Given node filters, deeply filters HTML tags.\n * Filters from the deepest nodes to the top.\n *\n * @param {string} HTML    The HTML to filter.\n * @param {Array}  filters An array of functions that can mutate with the provided node.\n * @param {Object} schema  The schema to use.\n *\n * @return {string} The filtered HTML.\n */\nexport function deepFilterHTML( HTML, filters = [], schema ) {\n\tconst doc = document.implementation.createHTMLDocument( '' );\n\n\tdoc.body.innerHTML = HTML;\n\n\tdeepFilterNodeList( doc.body.childNodes, filters, doc, schema );\n\n\treturn doc.body.innerHTML;\n}\n\n/**\n * Gets a sibling within text-level context.\n *\n * @param {Element} node  The subject node.\n * @param {string}  which \"next\" or \"previous\".\n */\nexport function getSibling( node, which ) {\n\tconst sibling = node[ `${ which }Sibling` ];\n\n\tif ( sibling && isPhrasingContent( sibling ) ) {\n\t\treturn sibling;\n\t}\n\n\tconst { parentNode } = node;\n\n\tif ( ! parentNode || ! isPhrasingContent( parentNode ) ) {\n\t\treturn;\n\t}\n\n\treturn getSibling( parentNode, which );\n}\n"]}