{"version":3,"sources":["@wordpress/rich-text/src/component/use-anchor.js"],"names":["useState","useLayoutEffect","getFormatElement","range","editableContentElement","tagName","className","element","startContainer","nextElementSibling","nodeType","ELEMENT_NODE","parentElement","contains","selector","matches","createVirtualAnchorElement","ownerDocument","getBoundingClientRect","getAnchor","defaultView","selection","getSelection","rangeCount","getRangeAt","formatElement","useAnchor","settings","anchor","setAnchor","callback","attach","addEventListener","detach","removeEventListener","activeElement"],"mappings":"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","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { useState, useLayoutEffect } from '@wordpress/element';\n\n/** @typedef {import('../register-format-type').WPFormat} WPFormat */\n/** @typedef {import('../types').RichTextValue} RichTextValue */\n\n/**\n * Given a range and a format tag name and class name, returns the closest\n * format element.\n *\n * @param {Range}       range                  The Range to check.\n * @param {HTMLElement} editableContentElement The editable wrapper.\n * @param {string}      tagName                The tag name of the format element.\n * @param {string}      className              The class name of the format element.\n *\n * @return {HTMLElement|undefined} The format element, if found.\n */\nfunction getFormatElement( range, editableContentElement, tagName, className ) {\n\tlet element = range.startContainer;\n\n\t// If the caret is right before the element, select the next element.\n\telement = element.nextElementSibling || element;\n\n\tif ( element.nodeType !== element.ELEMENT_NODE ) {\n\t\telement = element.parentElement;\n\t}\n\n\tif ( ! element ) return;\n\tif ( element === editableContentElement ) return;\n\tif ( ! editableContentElement.contains( element ) ) return;\n\n\tconst selector = tagName + ( className ? '.' + className : '' );\n\n\t// .closest( selector ), but with a boundary. Check if the element matches\n\t// the selector. If it doesn't match, try the parent element if it's not the\n\t// editable wrapper. We don't want to try to match ancestors of the editable\n\t// wrapper, which is what .closest( selector ) would do. When the element is\n\t// the editable wrapper (which is most likely the case because most text is\n\t// unformatted), this never runs.\n\twhile ( element !== editableContentElement ) {\n\t\tif ( element.matches( selector ) ) {\n\t\t\treturn element;\n\t\t}\n\n\t\telement = element.parentElement;\n\t}\n}\n\n/**\n * @typedef {Object} VirtualAnchorElement\n * @property {() => DOMRect} getBoundingClientRect A function returning a DOMRect\n * @property {Document}      ownerDocument         The element's ownerDocument\n */\n\n/**\n * Creates a virtual anchor element for a range.\n *\n * @param {Range}       range                  The range to create a virtual anchor element for.\n * @param {HTMLElement} editableContentElement The editable wrapper.\n *\n * @return {VirtualAnchorElement} The virtual anchor element.\n */\nfunction createVirtualAnchorElement( range, editableContentElement ) {\n\treturn {\n\t\townerDocument: range.startContainer.ownerDocument,\n\t\tgetBoundingClientRect() {\n\t\t\treturn editableContentElement.contains( range.startContainer )\n\t\t\t\t? range.getBoundingClientRect()\n\t\t\t\t: editableContentElement.getBoundingClientRect();\n\t\t},\n\t};\n}\n\n/**\n * Get the anchor: a format element if there is a matching one based on the\n * tagName and className or a range otherwise.\n *\n * @param {HTMLElement} editableContentElement The editable wrapper.\n * @param {string}      tagName                The tag name of the format\n *                                             element.\n * @param {string}      className              The class name of the format\n *                                             element.\n *\n * @return {HTMLElement|VirtualAnchorElement|undefined} The anchor.\n */\nfunction getAnchor( editableContentElement, tagName, className ) {\n\tif ( ! editableContentElement ) return;\n\n\tconst { ownerDocument } = editableContentElement;\n\tconst { defaultView } = ownerDocument;\n\tconst selection = defaultView.getSelection();\n\n\tif ( ! selection ) return;\n\tif ( ! selection.rangeCount ) return;\n\n\tconst range = selection.getRangeAt( 0 );\n\n\tif ( ! range || ! range.startContainer ) return;\n\n\tconst formatElement = getFormatElement(\n\t\trange,\n\t\teditableContentElement,\n\t\ttagName,\n\t\tclassName\n\t);\n\n\tif ( formatElement ) return formatElement;\n\n\treturn createVirtualAnchorElement( range, editableContentElement );\n}\n\n/**\n * This hook, to be used in a format type's Edit component, returns the active\n * element that is formatted, or a virtual element for the selection range if\n * no format is active. The returned value is meant to be used for positioning\n * UI, e.g. by passing it to the `Popover` component via the `anchor` prop.\n *\n * @param {Object}           $1                        Named parameters.\n * @param {HTMLElement|null} $1.editableContentElement The element containing\n *                                                     the editable content.\n * @param {WPFormat=}        $1.settings               The format type's settings.\n * @return {Element|VirtualAnchorElement|undefined|null} The active element or selection range.\n */\nexport function useAnchor( { editableContentElement, settings = {} } ) {\n\tconst { tagName, className } = settings;\n\tconst [ anchor, setAnchor ] = useState( () =>\n\t\tgetAnchor( editableContentElement, tagName, className )\n\t);\n\n\tuseLayoutEffect( () => {\n\t\tif ( ! editableContentElement ) return;\n\n\t\tconst { ownerDocument } = editableContentElement;\n\n\t\tfunction callback() {\n\t\t\tsetAnchor(\n\t\t\t\tgetAnchor( editableContentElement, tagName, className )\n\t\t\t);\n\t\t}\n\n\t\tfunction attach() {\n\t\t\townerDocument.addEventListener( 'selectionchange', callback );\n\t\t}\n\n\t\tfunction detach() {\n\t\t\townerDocument.removeEventListener( 'selectionchange', callback );\n\t\t}\n\n\t\tif ( editableContentElement === ownerDocument.activeElement ) {\n\t\t\tattach();\n\t\t}\n\n\t\teditableContentElement.addEventListener( 'focusin', attach );\n\t\teditableContentElement.addEventListener( 'focusout', detach );\n\n\t\treturn detach;\n\t}, [ editableContentElement, tagName, className ] );\n\n\treturn anchor;\n}\n"]}