import { createElement } from "@wordpress/element";

/**
 * WordPress dependencies
 */
import { __experimentalBorderBoxControl as BorderBoxControl, __experimentalHasSplitBorders as hasSplitBorders, __experimentalIsDefinedBorder as isDefinedBorder, __experimentalToolsPanel as ToolsPanel, __experimentalToolsPanelItem as ToolsPanelItem } from '@wordpress/components';
import { useCallback, useMemo } from '@wordpress/element';
import { __ } from '@wordpress/i18n';
/**
 * Internal dependencies
 */

import BorderRadiusControl from '../border-radius-control';
import { useColorsPerOrigin } from './hooks';
import { getValueFromVariable } from './utils';
export function useHasBorderPanel(settings) {
  const controls = [useHasBorderColorControl(settings), useHasBorderRadiusControl(settings), useHasBorderStyleControl(settings), useHasBorderWidthControl(settings)];
  return controls.some(Boolean);
}

function useHasBorderColorControl(settings) {
  var _settings$border;

  return settings === null || settings === void 0 ? void 0 : (_settings$border = settings.border) === null || _settings$border === void 0 ? void 0 : _settings$border.color;
}

function useHasBorderRadiusControl(settings) {
  var _settings$border2;

  return settings === null || settings === void 0 ? void 0 : (_settings$border2 = settings.border) === null || _settings$border2 === void 0 ? void 0 : _settings$border2.radius;
}

function useHasBorderStyleControl(settings) {
  var _settings$border3;

  return settings === null || settings === void 0 ? void 0 : (_settings$border3 = settings.border) === null || _settings$border3 === void 0 ? void 0 : _settings$border3.style;
}

function useHasBorderWidthControl(settings) {
  var _settings$border4;

  return settings === null || settings === void 0 ? void 0 : (_settings$border4 = settings.border) === null || _settings$border4 === void 0 ? void 0 : _settings$border4.width;
}

function applyFallbackStyle(border) {
  if (!border) {
    return border;
  }

  if (!border.style && (border.color || border.width)) {
    return { ...border,
      style: 'solid'
    };
  }

  return border;
}

function applyAllFallbackStyles(border) {
  if (!border) {
    return border;
  }

  if (hasSplitBorders(border)) {
    return {
      top: applyFallbackStyle(border.top),
      right: applyFallbackStyle(border.right),
      bottom: applyFallbackStyle(border.bottom),
      left: applyFallbackStyle(border.left)
    };
  }

  return applyFallbackStyle(border);
}

function BorderToolsPanel(_ref) {
  let {
    resetAllFilter,
    onChange,
    value,
    panelId,
    children
  } = _ref;

  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };

  return createElement(ToolsPanel, {
    label: __('Border'),
    resetAll: resetAll,
    panelId: panelId
  }, children);
}

const DEFAULT_CONTROLS = {
  radius: true,
  color: true,
  width: true
};
export default function BorderPanel(_ref2) {
  let {
    as: Wrapper = BorderToolsPanel,
    value,
    onChange,
    inheritedValue = value,
    settings,
    panelId,
    defaultControls = DEFAULT_CONTROLS
  } = _ref2;
  const colors = useColorsPerOrigin(settings);

  const decodeValue = rawValue => getValueFromVariable({
    settings
  }, '', rawValue);

  const encodeColorValue = colorValue => {
    const allColors = colors.flatMap(_ref3 => {
      let {
        colors: originColors
      } = _ref3;
      return originColors;
    });
    const colorObject = allColors.find(_ref4 => {
      let {
        color
      } = _ref4;
      return color === colorValue;
    });
    return colorObject ? 'var:preset|color|' + colorObject.slug : colorValue;
  };

  const decodeColorValue = useCallback(colorValue => {
    const allColors = colors.flatMap(_ref5 => {
      let {
        colors: originColors
      } = _ref5;
      return originColors;
    });
    const colorObject = allColors.find(_ref6 => {
      let {
        slug
      } = _ref6;
      return colorValue === 'var:preset|color|' + slug;
    });
    return colorObject ? colorObject.color : colorValue;
  }, [colors]);
  const border = useMemo(() => {
    var _inheritedValue$borde, _inheritedValue$borde2;

    if (hasSplitBorders(inheritedValue === null || inheritedValue === void 0 ? void 0 : inheritedValue.border)) {
      const borderValue = { ...(inheritedValue === null || inheritedValue === void 0 ? void 0 : inheritedValue.border)
      };
      ['top', 'right', 'bottom', 'left'].forEach(side => {
        var _borderValue$side;

        borderValue[side] = { ...borderValue[side],
          color: decodeColorValue((_borderValue$side = borderValue[side]) === null || _borderValue$side === void 0 ? void 0 : _borderValue$side.color)
        };
      });
      return borderValue;
    }

    return { ...(inheritedValue === null || inheritedValue === void 0 ? void 0 : inheritedValue.border),
      color: inheritedValue !== null && inheritedValue !== void 0 && (_inheritedValue$borde = inheritedValue.border) !== null && _inheritedValue$borde !== void 0 && _inheritedValue$borde.color ? decodeColorValue(inheritedValue === null || inheritedValue === void 0 ? void 0 : (_inheritedValue$borde2 = inheritedValue.border) === null || _inheritedValue$borde2 === void 0 ? void 0 : _inheritedValue$borde2.color) : undefined
    };
  }, [inheritedValue === null || inheritedValue === void 0 ? void 0 : inheritedValue.border, decodeColorValue]);

  const setBorder = newBorder => onChange({ ...value,
    border: newBorder
  });

  const showBorderColor = useHasBorderColorControl(settings);
  const showBorderStyle = useHasBorderStyleControl(settings);
  const showBorderWidth = useHasBorderWidthControl(settings); // Border radius.

  const showBorderRadius = useHasBorderRadiusControl(settings);
  const borderRadiusValues = decodeValue(border === null || border === void 0 ? void 0 : border.radius);

  const setBorderRadius = newBorderRadius => setBorder({ ...border,
    radius: newBorderRadius
  });

  const hasBorderRadius = () => {
    var _value$border;

    const borderValues = value === null || value === void 0 ? void 0 : (_value$border = value.border) === null || _value$border === void 0 ? void 0 : _value$border.radius;

    if (typeof borderValues === 'object') {
      return Object.entries(borderValues).some(Boolean);
    }

    return !!borderValues;
  };

  const resetBorder = () => {
    if (hasBorderRadius()) {
      var _value$border2;

      return setBorder({
        radius: value === null || value === void 0 ? void 0 : (_value$border2 = value.border) === null || _value$border2 === void 0 ? void 0 : _value$border2.radius
      });
    }

    setBorder(undefined);
  };

  const onBorderChange = newBorder => {
    // Ensure we have a visible border style when a border width or
    // color is being selected.
    const updatedBorder = applyAllFallbackStyles(newBorder);

    if (hasSplitBorders(updatedBorder)) {
      ['top', 'right', 'bottom', 'left'].forEach(side => {
        if (updatedBorder[side]) {
          var _updatedBorder$side;

          updatedBorder[side] = { ...updatedBorder[side],
            color: encodeColorValue((_updatedBorder$side = updatedBorder[side]) === null || _updatedBorder$side === void 0 ? void 0 : _updatedBorder$side.color)
          };
        }
      });
    } else if (updatedBorder) {
      updatedBorder.color = encodeColorValue(updatedBorder.color);
    } // As radius is maintained separately to color, style, and width
    // maintain its value. Undefined values here will be cleaned when
    // global styles are saved.


    setBorder({
      radius: border === null || border === void 0 ? void 0 : border.radius,
      ...updatedBorder
    });
  };

  const resetAllFilter = useCallback(previousValue => {
    return { ...previousValue,
      border: undefined
    };
  }, []);
  const showBorderByDefault = (defaultControls === null || defaultControls === void 0 ? void 0 : defaultControls.color) || (defaultControls === null || defaultControls === void 0 ? void 0 : defaultControls.width);
  return createElement(Wrapper, {
    resetAllFilter: resetAllFilter,
    value: value,
    onChange: onChange,
    panelId: panelId
  }, (showBorderWidth || showBorderColor) && createElement(ToolsPanelItem, {
    hasValue: () => isDefinedBorder(value === null || value === void 0 ? void 0 : value.border),
    label: __('Border'),
    onDeselect: () => resetBorder(),
    isShownByDefault: showBorderByDefault,
    panelId: panelId
  }, createElement(BorderBoxControl, {
    colors: colors,
    enableAlpha: true,
    enableStyle: showBorderStyle,
    onChange: onBorderChange,
    popoverOffset: 40,
    popoverPlacement: "left-start",
    value: border,
    __experimentalIsRenderedInSidebar: true,
    size: '__unstable-large'
  })), showBorderRadius && createElement(ToolsPanelItem, {
    hasValue: hasBorderRadius,
    label: __('Radius'),
    onDeselect: () => setBorderRadius(undefined),
    isShownByDefault: defaultControls.radius,
    panelId: panelId
  }, createElement(BorderRadiusControl, {
    values: borderRadiusValues,
    onChange: newValue => {
      setBorderRadius(newValue || undefined);
    }
  })));
}
//# sourceMappingURL=border-panel.js.map