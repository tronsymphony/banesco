import _extends from "@babel/runtime/helpers/esm/extends";
import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
import classnames from 'classnames';
/**
 * WordPress dependencies
 */

import { getBlockSupport } from '@wordpress/blocks';
import { __experimentalHasSplitBorders as hasSplitBorders } from '@wordpress/components';
import { createHigherOrderComponent } from '@wordpress/compose';
import { Platform, useCallback, useMemo } from '@wordpress/element';
import { addFilter } from '@wordpress/hooks';
/**
 * Internal dependencies
 */

import { getColorClassName } from '../components/colors';
import InspectorControls from '../components/inspector-controls';
import useMultipleOriginColorsAndGradients from '../components/colors-gradients/use-multiple-origin-colors-and-gradients';
import { cleanEmptyObject, shouldSkipSerialization, useBlockSettings } from './utils';
import { useHasBorderPanel, BorderPanel as StylesBorderPanel } from '../components/global-styles';
export const BORDER_SUPPORT_KEY = '__experimentalBorder';

const getColorByProperty = (colors, property, value) => {
  let matchedColor;
  colors.some(origin => origin.colors.some(color => {
    if (color[property] === value) {
      matchedColor = color;
      return true;
    }

    return false;
  }));
  return matchedColor;
};

export const getMultiOriginColor = _ref => {
  let {
    colors,
    namedColor,
    customColor
  } = _ref;

  // Search each origin (default, theme, or user) for matching color by name.
  if (namedColor) {
    const colorObject = getColorByProperty(colors, 'slug', namedColor);

    if (colorObject) {
      return colorObject;
    }
  } // Skip if no custom color or matching named color.


  if (!customColor) {
    return {
      color: undefined
    };
  } // Attempt to find color via custom color value or build new object.


  const colorObject = getColorByProperty(colors, 'color', customColor);
  return colorObject ? colorObject : {
    color: customColor
  };
};

function getColorSlugFromVariable(value) {
  const namedColor = /var:preset\|color\|(.+)/.exec(value);

  if (namedColor && namedColor[1]) {
    return namedColor[1];
  }

  return null;
}

function styleToAttributes(style) {
  var _style$border;

  if (hasSplitBorders(style === null || style === void 0 ? void 0 : style.border)) {
    return {
      style,
      borderColor: undefined
    };
  }

  const borderColorValue = style === null || style === void 0 ? void 0 : (_style$border = style.border) === null || _style$border === void 0 ? void 0 : _style$border.color;
  const borderColorSlug = borderColorValue !== null && borderColorValue !== void 0 && borderColorValue.startsWith('var:preset|color|') ? borderColorValue.substring('var:preset|color|'.length) : undefined;
  const updatedStyle = { ...style
  };
  updatedStyle.border = { ...updatedStyle.border,
    color: borderColorSlug ? undefined : borderColorValue
  };
  return {
    style: cleanEmptyObject(updatedStyle),
    borderColor: borderColorSlug
  };
}

function attributesToStyle(attributes) {
  var _attributes$style, _attributes$style2, _attributes$style3, _attributes$style3$bo;

  if (hasSplitBorders((_attributes$style = attributes.style) === null || _attributes$style === void 0 ? void 0 : _attributes$style.border)) {
    return attributes.style;
  }

  return { ...attributes.style,
    border: { ...((_attributes$style2 = attributes.style) === null || _attributes$style2 === void 0 ? void 0 : _attributes$style2.border),
      color: attributes.borderColor ? 'var:preset|color|' + attributes.borderColor : (_attributes$style3 = attributes.style) === null || _attributes$style3 === void 0 ? void 0 : (_attributes$style3$bo = _attributes$style3.border) === null || _attributes$style3$bo === void 0 ? void 0 : _attributes$style3$bo.color
    }
  };
}

function BordersInspectorControl(_ref2) {
  let {
    children,
    resetAllFilter
  } = _ref2;
  const attributesResetAllFilter = useCallback(attributes => {
    const existingStyle = attributesToStyle(attributes);
    const updatedStyle = resetAllFilter(existingStyle);
    return { ...attributes,
      ...styleToAttributes(updatedStyle)
    };
  }, [resetAllFilter]);
  return createElement(InspectorControls, {
    group: "border",
    resetAllFilter: attributesResetAllFilter
  }, children);
}

export function BorderPanel(props) {
  const {
    clientId,
    name,
    attributes,
    setAttributes
  } = props;
  const settings = useBlockSettings(name);
  const isEnabled = useHasBorderPanel(settings);
  const value = useMemo(() => {
    return attributesToStyle({
      style: attributes.style,
      borderColor: attributes.borderColor
    });
  }, [attributes.style, attributes.borderColor]);

  const onChange = newStyle => {
    setAttributes(styleToAttributes(newStyle));
  };

  if (!isEnabled) {
    return null;
  }

  const defaultControls = getBlockSupport(props.name, [BORDER_SUPPORT_KEY, '__experimentalDefaultControls']);
  return createElement(StylesBorderPanel, {
    as: BordersInspectorControl,
    panelId: clientId,
    settings: settings,
    value: value,
    onChange: onChange,
    defaultControls: defaultControls
  });
}
/**
 * Determine whether there is block support for border properties.
 *
 * @param {string} blockName Block name.
 * @param {string} feature   Border feature to check support for.
 *
 * @return {boolean} Whether there is support.
 */

export function hasBorderSupport(blockName) {
  let feature = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'any';

  if (Platform.OS !== 'web') {
    return false;
  }

  const support = getBlockSupport(blockName, BORDER_SUPPORT_KEY);

  if (support === true) {
    return true;
  }

  if (feature === 'any') {
    return !!(support !== null && support !== void 0 && support.color || support !== null && support !== void 0 && support.radius || support !== null && support !== void 0 && support.width || support !== null && support !== void 0 && support.style);
  }

  return !!(support !== null && support !== void 0 && support[feature]);
}
/**
 * Returns a new style object where the specified border attribute has been
 * removed.
 *
 * @param {Object} style     Styles from block attributes.
 * @param {string} attribute The border style attribute to clear.
 *
 * @return {Object} Style object with the specified attribute removed.
 */

export function removeBorderAttribute(style, attribute) {
  return cleanEmptyObject({ ...style,
    border: { ...(style === null || style === void 0 ? void 0 : style.border),
      [attribute]: undefined
    }
  });
}
/**
 * Filters registered block settings, extending attributes to include
 * `borderColor` if needed.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Updated block settings.
 */

function addAttributes(settings) {
  if (!hasBorderSupport(settings, 'color')) {
    return settings;
  } // Allow blocks to specify default value if needed.


  if (settings.attributes.borderColor) {
    return settings;
  } // Add new borderColor attribute to block settings.


  return { ...settings,
    attributes: { ...settings.attributes,
      borderColor: {
        type: 'string'
      }
    }
  };
}
/**
 * Override props assigned to save component to inject border color.
 *
 * @param {Object} props      Additional props applied to save element.
 * @param {Object} blockType  Block type definition.
 * @param {Object} attributes Block's attributes.
 *
 * @return {Object} Filtered props to apply to save element.
 */


function addSaveProps(props, blockType, attributes) {
  if (!hasBorderSupport(blockType, 'color') || shouldSkipSerialization(blockType, BORDER_SUPPORT_KEY, 'color')) {
    return props;
  }

  const borderClasses = getBorderClasses(attributes);
  const newClassName = classnames(props.className, borderClasses); // If we are clearing the last of the previous classes in `className`
  // set it to `undefined` to avoid rendering empty DOM attributes.

  props.className = newClassName ? newClassName : undefined;
  return props;
}
/**
 * Generates a CSS class name consisting of all the applicable border color
 * classes given the current block attributes.
 *
 * @param {Object} attributes Block's attributes.
 *
 * @return {string} CSS class name.
 */


export function getBorderClasses(attributes) {
  var _style$border2;

  const {
    borderColor,
    style
  } = attributes;
  const borderColorClass = getColorClassName('border-color', borderColor);
  return classnames({
    'has-border-color': borderColor || (style === null || style === void 0 ? void 0 : (_style$border2 = style.border) === null || _style$border2 === void 0 ? void 0 : _style$border2.color),
    [borderColorClass]: !!borderColorClass
  });
}
/**
 * Filters the registered block settings to apply border color styles and
 * classnames to the block edit wrapper.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function addEditProps(settings) {
  if (!hasBorderSupport(settings, 'color') || shouldSkipSerialization(settings, BORDER_SUPPORT_KEY, 'color')) {
    return settings;
  }

  const existingGetEditWrapperProps = settings.getEditWrapperProps;

  settings.getEditWrapperProps = attributes => {
    let props = {};

    if (existingGetEditWrapperProps) {
      props = existingGetEditWrapperProps(attributes);
    }

    return addSaveProps(props, settings, attributes);
  };

  return settings;
}
/**
 * This adds inline styles for color palette colors.
 * Ideally, this is not needed and themes should load their palettes on the editor.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */


export const withBorderColorPaletteStyles = createHigherOrderComponent(BlockListBlock => props => {
  var _style$border3, _style$border3$top, _style$border4, _style$border4$right, _style$border5, _style$border5$bottom, _style$border6, _style$border6$left, _props$wrapperProps;

  const {
    name,
    attributes
  } = props;
  const {
    borderColor,
    style
  } = attributes;
  const {
    colors
  } = useMultipleOriginColorsAndGradients();

  if (!hasBorderSupport(name, 'color') || shouldSkipSerialization(name, BORDER_SUPPORT_KEY, 'color')) {
    return createElement(BlockListBlock, props);
  }

  const {
    color: borderColorValue
  } = getMultiOriginColor({
    colors,
    namedColor: borderColor
  });
  const {
    color: borderTopColor
  } = getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style === null || style === void 0 ? void 0 : (_style$border3 = style.border) === null || _style$border3 === void 0 ? void 0 : (_style$border3$top = _style$border3.top) === null || _style$border3$top === void 0 ? void 0 : _style$border3$top.color)
  });
  const {
    color: borderRightColor
  } = getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style === null || style === void 0 ? void 0 : (_style$border4 = style.border) === null || _style$border4 === void 0 ? void 0 : (_style$border4$right = _style$border4.right) === null || _style$border4$right === void 0 ? void 0 : _style$border4$right.color)
  });
  const {
    color: borderBottomColor
  } = getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style === null || style === void 0 ? void 0 : (_style$border5 = style.border) === null || _style$border5 === void 0 ? void 0 : (_style$border5$bottom = _style$border5.bottom) === null || _style$border5$bottom === void 0 ? void 0 : _style$border5$bottom.color)
  });
  const {
    color: borderLeftColor
  } = getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style === null || style === void 0 ? void 0 : (_style$border6 = style.border) === null || _style$border6 === void 0 ? void 0 : (_style$border6$left = _style$border6.left) === null || _style$border6$left === void 0 ? void 0 : _style$border6$left.color)
  });
  const extraStyles = {
    borderTopColor: borderTopColor || borderColorValue,
    borderRightColor: borderRightColor || borderColorValue,
    borderBottomColor: borderBottomColor || borderColorValue,
    borderLeftColor: borderLeftColor || borderColorValue
  };
  let wrapperProps = props.wrapperProps;
  wrapperProps = { ...props.wrapperProps,
    style: { ...((_props$wrapperProps = props.wrapperProps) === null || _props$wrapperProps === void 0 ? void 0 : _props$wrapperProps.style),
      ...extraStyles
    }
  };
  return createElement(BlockListBlock, _extends({}, props, {
    wrapperProps: wrapperProps
  }));
});
addFilter('blocks.registerBlockType', 'core/border/addAttributes', addAttributes);
addFilter('blocks.getSaveContent.extraProps', 'core/border/addSaveProps', addSaveProps);
addFilter('blocks.registerBlockType', 'core/border/addEditProps', addEditProps);
addFilter('editor.BlockListBlock', 'core/border/with-border-color-palette-styles', withBorderColorPaletteStyles);
//# sourceMappingURL=border.js.map