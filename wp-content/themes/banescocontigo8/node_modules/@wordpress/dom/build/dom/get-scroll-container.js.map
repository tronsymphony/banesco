{"version":3,"sources":["@wordpress/dom/src/dom/get-scroll-container.js"],"names":["getScrollContainer","node","direction","undefined","scrollHeight","clientHeight","overflowY","test","scrollWidth","clientWidth","overflowX","ownerDocument","parentNode"],"mappings":";;;;;;;;;AAGA;;AAHA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASA,kBAAT,CAA6BC,IAA7B,EAA4D;AAAA,MAAzBC,SAAyB,uEAAb,UAAa;;AAC1E,MAAK,CAAED,IAAP,EAAc;AACb,WAAOE,SAAP;AACA;;AAED,MAAKD,SAAS,KAAK,UAAd,IAA4BA,SAAS,KAAK,KAA/C,EAAuD;AACtD;AACA,QAAKD,IAAI,CAACG,YAAL,GAAoBH,IAAI,CAACI,YAA9B,EAA6C;AAC5C;AACA,YAAM;AAAEC,QAAAA;AAAF,UAAgB,+BAAkBL,IAAlB,CAAtB;;AAEA,UAAK,gBAAgBM,IAAhB,CAAsBD,SAAtB,CAAL,EAAyC;AACxC,eAAOL,IAAP;AACA;AACD;AACD;;AAED,MAAKC,SAAS,KAAK,YAAd,IAA8BA,SAAS,KAAK,KAAjD,EAAyD;AACxD;AACA,QAAKD,IAAI,CAACO,WAAL,GAAmBP,IAAI,CAACQ,WAA7B,EAA2C;AAC1C;AACA,YAAM;AAAEC,QAAAA;AAAF,UAAgB,+BAAkBT,IAAlB,CAAtB;;AAEA,UAAK,gBAAgBM,IAAhB,CAAsBG,SAAtB,CAAL,EAAyC;AACxC,eAAOT,IAAP;AACA;AACD;AACD;;AAED,MAAKA,IAAI,CAACU,aAAL,KAAuBV,IAAI,CAACW,UAAjC,EAA8C;AAC7C,WAAOX,IAAP;AACA,GA/ByE,CAiC1E;;;AACA,SAAOD,kBAAkB;AACxB;AAAyBC,EAAAA,IAAI,CAACW,UADN,EAExBV,SAFwB,CAAzB;AAIA","sourcesContent":["/**\n * Internal dependencies\n */\nimport getComputedStyle from './get-computed-style';\n\n/**\n * Given a DOM node, finds the closest scrollable container node or the node\n * itself, if scrollable.\n *\n * @param {Element | null} node      Node from which to start.\n * @param {?string}        direction Direction of scrollable container to search for ('vertical', 'horizontal', 'all').\n *                                   Defaults to 'vertical'.\n * @return {Element | undefined} Scrollable container node, if found.\n */\nexport default function getScrollContainer( node, direction = 'vertical' ) {\n\tif ( ! node ) {\n\t\treturn undefined;\n\t}\n\n\tif ( direction === 'vertical' || direction === 'all' ) {\n\t\t// Scrollable if scrollable height exceeds displayed...\n\t\tif ( node.scrollHeight > node.clientHeight ) {\n\t\t\t// ...except when overflow is defined to be hidden or visible\n\t\t\tconst { overflowY } = getComputedStyle( node );\n\n\t\t\tif ( /(auto|scroll)/.test( overflowY ) ) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( direction === 'horizontal' || direction === 'all' ) {\n\t\t// Scrollable if scrollable width exceeds displayed...\n\t\tif ( node.scrollWidth > node.clientWidth ) {\n\t\t\t// ...except when overflow is defined to be hidden or visible\n\t\t\tconst { overflowX } = getComputedStyle( node );\n\n\t\t\tif ( /(auto|scroll)/.test( overflowX ) ) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( node.ownerDocument === node.parentNode ) {\n\t\treturn node;\n\t}\n\n\t// Continue traversing.\n\treturn getScrollContainer(\n\t\t/** @type {Element} */ ( node.parentNode ),\n\t\tdirection\n\t);\n}\n"]}