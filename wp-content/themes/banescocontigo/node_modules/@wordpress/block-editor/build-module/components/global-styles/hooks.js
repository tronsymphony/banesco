/**
 * External dependencies
 */
import fastDeepEqual from 'fast-deep-equal/es6';
import { get, set } from 'lodash';
/**
 * WordPress dependencies
 */

import { useContext, useCallback, useMemo } from '@wordpress/element';
import { useSelect } from '@wordpress/data';
import { store as blocksStore } from '@wordpress/blocks';
import { _x } from '@wordpress/i18n';
/**
 * Internal dependencies
 */

import { getValueFromVariable, getPresetVariableFromValue } from './utils';
import { GlobalStylesContext } from './context';
import { unlock } from '../../lock-unlock';
const EMPTY_CONFIG = {
  settings: {},
  styles: {}
};
const VALID_SETTINGS = ['appearanceTools', 'useRootPaddingAwareAlignments', 'border.color', 'border.radius', 'border.style', 'border.width', 'shadow.presets', 'shadow.defaultPresets', 'color.background', 'color.button', 'color.caption', 'color.custom', 'color.customDuotone', 'color.customGradient', 'color.defaultDuotone', 'color.defaultGradients', 'color.defaultPalette', 'color.duotone', 'color.gradients', 'color.heading', 'color.link', 'color.palette', 'color.text', 'custom', 'dimensions.minHeight', 'layout.contentSize', 'layout.definitions', 'layout.wideSize', 'position.fixed', 'position.sticky', 'spacing.customSpacingSize', 'spacing.spacingSizes', 'spacing.spacingScale', 'spacing.blockGap', 'spacing.margin', 'spacing.padding', 'spacing.units', 'typography.fluid', 'typography.customFontSize', 'typography.dropCap', 'typography.fontFamilies', 'typography.fontSizes', 'typography.fontStyle', 'typography.fontWeight', 'typography.letterSpacing', 'typography.lineHeight', 'typography.textColumns', 'typography.textDecoration', 'typography.textTransform'];
export const useGlobalStylesReset = () => {
  const {
    user: config,
    setUserConfig
  } = useContext(GlobalStylesContext);
  const canReset = !!config && !fastDeepEqual(config, EMPTY_CONFIG);
  return [canReset, useCallback(() => setUserConfig(() => EMPTY_CONFIG), [setUserConfig])];
};
export function useGlobalSetting(propertyPath, blockName) {
  let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'all';
  const {
    setUserConfig,
    ...configs
  } = useContext(GlobalStylesContext);
  const appendedBlockPath = blockName ? '.blocks.' + blockName : '';
  const appendedPropertyPath = propertyPath ? '.' + propertyPath : '';
  const contextualPath = `settings${appendedBlockPath}${appendedPropertyPath}`;
  const globalPath = `settings${appendedPropertyPath}`;
  const sourceKey = source === 'all' ? 'merged' : source;
  const settingValue = useMemo(() => {
    const configToUse = configs[sourceKey];

    if (!configToUse) {
      throw 'Unsupported source';
    }

    if (propertyPath) {
      var _get;

      return (_get = get(configToUse, contextualPath)) !== null && _get !== void 0 ? _get : get(configToUse, globalPath);
    }

    const result = {};
    VALID_SETTINGS.forEach(setting => {
      var _get2;

      const value = (_get2 = get(configToUse, `settings${appendedBlockPath}.${setting}`)) !== null && _get2 !== void 0 ? _get2 : get(configToUse, `settings.${setting}`);

      if (value) {
        set(result, setting, value);
      }
    });
    return result;
  }, [configs, sourceKey, propertyPath, contextualPath, globalPath, appendedBlockPath]);

  const setSetting = newValue => {
    setUserConfig(currentConfig => {
      // Deep clone `currentConfig` to avoid mutating it later.
      const newUserConfig = JSON.parse(JSON.stringify(currentConfig));
      set(newUserConfig, contextualPath, newValue);
      return newUserConfig;
    });
  };

  return [settingValue, setSetting];
}
export function useGlobalStyle(path, blockName) {
  let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'all';
  let {
    shouldDecodeEncode = true
  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  const {
    merged: mergedConfig,
    base: baseConfig,
    user: userConfig,
    setUserConfig
  } = useContext(GlobalStylesContext);
  const appendedPath = path ? '.' + path : '';
  const finalPath = !blockName ? `styles${appendedPath}` : `styles.blocks.${blockName}${appendedPath}`;

  const setStyle = newValue => {
    setUserConfig(currentConfig => {
      // Deep clone `currentConfig` to avoid mutating it later.
      const newUserConfig = JSON.parse(JSON.stringify(currentConfig));
      set(newUserConfig, finalPath, shouldDecodeEncode ? getPresetVariableFromValue(mergedConfig.settings, blockName, path, newValue) : newValue);
      return newUserConfig;
    });
  };

  let rawResult, result;

  switch (source) {
    case 'all':
      rawResult = // The styles.css path is allowed to be empty, so don't revert to base if undefined.
      finalPath === 'styles.css' ? get(userConfig, finalPath) : get(mergedConfig, finalPath);
      result = shouldDecodeEncode ? getValueFromVariable(mergedConfig, blockName, rawResult) : rawResult;
      break;

    case 'user':
      rawResult = get(userConfig, finalPath);
      result = shouldDecodeEncode ? getValueFromVariable(mergedConfig, blockName, rawResult) : rawResult;
      break;

    case 'base':
      rawResult = get(baseConfig, finalPath);
      result = shouldDecodeEncode ? getValueFromVariable(baseConfig, blockName, rawResult) : rawResult;
      break;

    default:
      throw 'Unsupported source';
  }

  return [result, setStyle];
}
/**
 * React hook that overrides a global settings object with block and element specific settings.
 *
 * @param {Object}     parentSettings Settings object.
 * @param {blockName?} blockName      Block name.
 * @param {element?}   element        Element name.
 *
 * @return {Object} Merge of settings and supports.
 */

export function useSettingsForBlockElement(parentSettings, blockName, element) {
  const {
    supportedStyles,
    supports
  } = useSelect(select => {
    var _select$getBlockType;

    return {
      supportedStyles: unlock(select(blocksStore)).getSupportedStyles(blockName, element),
      supports: (_select$getBlockType = select(blocksStore).getBlockType(blockName)) === null || _select$getBlockType === void 0 ? void 0 : _select$getBlockType.supports
    };
  }, [blockName, element]);
  return useMemo(() => {
    var _updatedSettings$colo, _updatedSettings$colo2, _updatedSettings$colo3, _updatedSettings$colo4, _updatedSettings$colo5, _updatedSettings$colo6;

    const updatedSettings = { ...parentSettings
    };

    if (!supportedStyles.includes('fontSize')) {
      updatedSettings.typography = { ...updatedSettings.typography,
        fontSizes: {},
        customFontSize: false
      };
    }

    if (!supportedStyles.includes('fontFamily')) {
      updatedSettings.typography = { ...updatedSettings.typography,
        fontFamilies: {}
      };
    }

    updatedSettings.color = { ...updatedSettings.color,
      text: ((_updatedSettings$colo = updatedSettings.color) === null || _updatedSettings$colo === void 0 ? void 0 : _updatedSettings$colo.text) && supportedStyles.includes('color'),
      background: ((_updatedSettings$colo2 = updatedSettings.color) === null || _updatedSettings$colo2 === void 0 ? void 0 : _updatedSettings$colo2.background) && (supportedStyles.includes('background') || supportedStyles.includes('backgroundColor')),
      button: ((_updatedSettings$colo3 = updatedSettings.color) === null || _updatedSettings$colo3 === void 0 ? void 0 : _updatedSettings$colo3.button) && supportedStyles.includes('buttonColor'),
      heading: ((_updatedSettings$colo4 = updatedSettings.color) === null || _updatedSettings$colo4 === void 0 ? void 0 : _updatedSettings$colo4.heading) && supportedStyles.includes('headingColor'),
      link: ((_updatedSettings$colo5 = updatedSettings.color) === null || _updatedSettings$colo5 === void 0 ? void 0 : _updatedSettings$colo5.link) && supportedStyles.includes('linkColor'),
      caption: ((_updatedSettings$colo6 = updatedSettings.color) === null || _updatedSettings$colo6 === void 0 ? void 0 : _updatedSettings$colo6.caption) && supportedStyles.includes('captionColor')
    }; // Some blocks can enable background colors but disable gradients.

    if (!supportedStyles.includes('background')) {
      updatedSettings.color.gradients = [];
      updatedSettings.color.customGradient = false;
    } // If filters are not supported by the block/element, disable duotone.


    if (!supportedStyles.includes('filter')) {
      updatedSettings.color.defaultDuotone = false;
      updatedSettings.color.customDuotone = false;
    }

    ['lineHeight', 'fontStyle', 'fontWeight', 'letterSpacing', 'textTransform', 'textDecoration'].forEach(key => {
      if (!supportedStyles.includes(key)) {
        updatedSettings.typography = { ...updatedSettings.typography,
          [key]: false
        };
      }
    }); // The column-count style is named text column to reduce confusion with
    // the columns block and manage expectations from the support.
    // See: https://github.com/WordPress/gutenberg/pull/33587

    if (!supportedStyles.includes('columnCount')) {
      updatedSettings.typography = { ...updatedSettings.typography,
        textColumns: false
      };
    }

    ['contentSize', 'wideSize'].forEach(key => {
      if (!supportedStyles.includes(key)) {
        updatedSettings.layout = { ...updatedSettings.layout,
          [key]: false
        };
      }
    });
    ['padding', 'margin', 'blockGap'].forEach(key => {
      var _supports$spacing, _supports$spacing2, _supports$spacing3, _supports$spacing3$ke;

      if (!supportedStyles.includes(key)) {
        updatedSettings.spacing = { ...updatedSettings.spacing,
          [key]: false
        };
      }

      const sides = Array.isArray(supports === null || supports === void 0 ? void 0 : (_supports$spacing = supports.spacing) === null || _supports$spacing === void 0 ? void 0 : _supports$spacing[key]) ? supports === null || supports === void 0 ? void 0 : (_supports$spacing2 = supports.spacing) === null || _supports$spacing2 === void 0 ? void 0 : _supports$spacing2[key] : supports === null || supports === void 0 ? void 0 : (_supports$spacing3 = supports.spacing) === null || _supports$spacing3 === void 0 ? void 0 : (_supports$spacing3$ke = _supports$spacing3[key]) === null || _supports$spacing3$ke === void 0 ? void 0 : _supports$spacing3$ke.sides;

      if (sides !== null && sides !== void 0 && sides.length) {
        var _updatedSettings$spac;

        updatedSettings.spacing = { ...updatedSettings.spacing,
          [key]: { ...((_updatedSettings$spac = updatedSettings.spacing) === null || _updatedSettings$spac === void 0 ? void 0 : _updatedSettings$spac[key]),
            sides
          }
        };
      }
    });

    if (!supportedStyles.includes('minHeight')) {
      updatedSettings.dimensions = { ...updatedSettings.dimensions,
        minHeight: false
      };
    }

    ['radius', 'color', 'style', 'width'].forEach(key => {
      if (!supportedStyles.includes('border' + key.charAt(0).toUpperCase() + key.slice(1))) {
        updatedSettings.border = { ...updatedSettings.border,
          [key]: false
        };
      }
    });
    updatedSettings.shadow = supportedStyles.includes('shadow') ? updatedSettings.shadow : false;
    return updatedSettings;
  }, [parentSettings, supportedStyles, supports]);
}
export function useColorsPerOrigin(settings) {
  var _settings$color, _settings$color$palet, _settings$color2, _settings$color2$pale, _settings$color3, _settings$color3$pale, _settings$color4;

  const customColors = settings === null || settings === void 0 ? void 0 : (_settings$color = settings.color) === null || _settings$color === void 0 ? void 0 : (_settings$color$palet = _settings$color.palette) === null || _settings$color$palet === void 0 ? void 0 : _settings$color$palet.custom;
  const themeColors = settings === null || settings === void 0 ? void 0 : (_settings$color2 = settings.color) === null || _settings$color2 === void 0 ? void 0 : (_settings$color2$pale = _settings$color2.palette) === null || _settings$color2$pale === void 0 ? void 0 : _settings$color2$pale.theme;
  const defaultColors = settings === null || settings === void 0 ? void 0 : (_settings$color3 = settings.color) === null || _settings$color3 === void 0 ? void 0 : (_settings$color3$pale = _settings$color3.palette) === null || _settings$color3$pale === void 0 ? void 0 : _settings$color3$pale.default;
  const shouldDisplayDefaultColors = settings === null || settings === void 0 ? void 0 : (_settings$color4 = settings.color) === null || _settings$color4 === void 0 ? void 0 : _settings$color4.defaultPalette;
  return useMemo(() => {
    const result = [];

    if (themeColors && themeColors.length) {
      result.push({
        name: _x('Theme', 'Indicates this palette comes from the theme.'),
        colors: themeColors
      });
    }

    if (shouldDisplayDefaultColors && defaultColors && defaultColors.length) {
      result.push({
        name: _x('Default', 'Indicates this palette comes from WordPress.'),
        colors: defaultColors
      });
    }

    if (customColors && customColors.length) {
      result.push({
        name: _x('Custom', 'Indicates this palette is created by the user.'),
        colors: customColors
      });
    }

    return result;
  }, [customColors, themeColors, defaultColors, shouldDisplayDefaultColors]);
}
export function useGradientsPerOrigin(settings) {
  var _settings$color5, _settings$color5$grad, _settings$color6, _settings$color6$grad, _settings$color7, _settings$color7$grad, _settings$color8;

  const customGradients = settings === null || settings === void 0 ? void 0 : (_settings$color5 = settings.color) === null || _settings$color5 === void 0 ? void 0 : (_settings$color5$grad = _settings$color5.gradients) === null || _settings$color5$grad === void 0 ? void 0 : _settings$color5$grad.custom;
  const themeGradients = settings === null || settings === void 0 ? void 0 : (_settings$color6 = settings.color) === null || _settings$color6 === void 0 ? void 0 : (_settings$color6$grad = _settings$color6.gradients) === null || _settings$color6$grad === void 0 ? void 0 : _settings$color6$grad.theme;
  const defaultGradients = settings === null || settings === void 0 ? void 0 : (_settings$color7 = settings.color) === null || _settings$color7 === void 0 ? void 0 : (_settings$color7$grad = _settings$color7.gradients) === null || _settings$color7$grad === void 0 ? void 0 : _settings$color7$grad.default;
  const shouldDisplayDefaultGradients = settings === null || settings === void 0 ? void 0 : (_settings$color8 = settings.color) === null || _settings$color8 === void 0 ? void 0 : _settings$color8.defaultGradients;
  return useMemo(() => {
    const result = [];

    if (themeGradients && themeGradients.length) {
      result.push({
        name: _x('Theme', 'Indicates this palette comes from the theme.'),
        gradients: themeGradients
      });
    }

    if (shouldDisplayDefaultGradients && defaultGradients && defaultGradients.length) {
      result.push({
        name: _x('Default', 'Indicates this palette comes from WordPress.'),
        gradients: defaultGradients
      });
    }

    if (customGradients && customGradients.length) {
      result.push({
        name: _x('Custom', 'Indicates this palette is created by the user.'),
        gradients: customGradients
      });
    }

    return result;
  }, [customGradients, themeGradients, defaultGradients, shouldDisplayDefaultGradients]);
}
//# sourceMappingURL=hooks.js.map