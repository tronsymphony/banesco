{"version":3,"sources":["@wordpress/block-editor/src/components/inserter/media-tab/hooks.js"],"names":["useEffect","useState","useRef","useMemo","useSelect","store","blockEditorStore","useMediaResults","category","query","mediaList","setMediaList","isLoading","setIsLoading","lastRequest","key","JSON","stringify","name","current","_media","fetch","Object","values","useInserterMediaCategories","inserterMediaCategories","allowedMimeTypes","enableOpenverseMediaCategory","select","settings","getSettings","allowedCategories","filter","isExternalResource","some","mimeType","startsWith","mediaType","useMediaCategories","rootClientId","categories","setCategories","canInsertImage","canInsertVideo","canInsertAudio","canInsertBlockType","_categories","categoriesHaveMedia","Map","Promise","all","map","results","per_page","length","canInsertMediaType","image","video","audio","forEach","get","push"],"mappings":"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","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { useEffect, useState, useRef, useMemo } from '@wordpress/element';\nimport { useSelect } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport { store as blockEditorStore } from '../../../store';\n\n/**\n * Interface for inserter media requests.\n *\n * @typedef {Object} InserterMediaRequest\n * @property {number} per_page How many items to fetch per page.\n * @property {string} search   The search term to use for filtering the results.\n */\n\n/**\n * Interface for inserter media responses. Any media resource should\n * map their response to this interface, in order to create the core\n * WordPress media blocks (image, video, audio).\n *\n * @typedef {Object} InserterMediaItem\n * @property {string}        title        The title of the media item.\n * @property {string}        url          The source url of the media item.\n * @property {string}        [previewUrl] The preview source url of the media item to display in the media list.\n * @property {number}        [id]         The WordPress id of the media item.\n * @property {number|string} [sourceId]   The id of the media item from external source.\n * @property {string}        [alt]        The alt text of the media item.\n * @property {string}        [caption]    The caption of the media item.\n */\n\n/**\n * Fetches media items based on the provided category.\n * Each media category is responsible for providing a `fetch` function.\n *\n * @param {Object}               category The media category to fetch results for.\n * @param {InserterMediaRequest} query    The query args to use for the request.\n * @return {InserterMediaItem[]} The media results.\n */\nexport function useMediaResults( category, query = {} ) {\n\tconst [ mediaList, setMediaList ] = useState();\n\tconst [ isLoading, setIsLoading ] = useState( false );\n\t// We need to keep track of the last request made because\n\t// multiple request can be fired without knowing the order\n\t// of resolution, and we need to ensure we are showing\n\t// the results of the last request.\n\t// In the future we could use AbortController to cancel previous\n\t// requests, but we don't for now as it involves adding support\n\t// for this to `core-data` package.\n\tconst lastRequest = useRef();\n\tuseEffect( () => {\n\t\t( async () => {\n\t\t\tconst key = JSON.stringify( {\n\t\t\t\tcategory: category.name,\n\t\t\t\t...query,\n\t\t\t} );\n\t\t\tlastRequest.current = key;\n\t\t\tsetIsLoading( true );\n\t\t\tsetMediaList( [] ); // Empty the previous results.\n\t\t\tconst _media = await category.fetch?.( query );\n\t\t\tif ( key === lastRequest.current ) {\n\t\t\t\tsetMediaList( _media );\n\t\t\t\tsetIsLoading( false );\n\t\t\t}\n\t\t} )();\n\t}, [ category.name, ...Object.values( query ) ] );\n\treturn { mediaList, isLoading };\n}\n\nfunction useInserterMediaCategories() {\n\tconst {\n\t\tinserterMediaCategories,\n\t\tallowedMimeTypes,\n\t\tenableOpenverseMediaCategory,\n\t} = useSelect( ( select ) => {\n\t\tconst settings = select( blockEditorStore ).getSettings();\n\t\treturn {\n\t\t\tinserterMediaCategories: settings.inserterMediaCategories,\n\t\t\tallowedMimeTypes: settings.allowedMimeTypes,\n\t\t\tenableOpenverseMediaCategory: settings.enableOpenverseMediaCategory,\n\t\t};\n\t}, [] );\n\t// The allowed `mime_types` can be altered by `upload_mimes` filter and restrict\n\t// some of them. In this case we shouldn't add the category to the available media\n\t// categories list in the inserter.\n\tconst allowedCategories = useMemo( () => {\n\t\tif ( ! inserterMediaCategories || ! allowedMimeTypes ) {\n\t\t\treturn;\n\t\t}\n\t\treturn inserterMediaCategories.filter( ( category ) => {\n\t\t\t// Check if Openverse category is enabled.\n\t\t\tif (\n\t\t\t\t! enableOpenverseMediaCategory &&\n\t\t\t\tcategory.name === 'openverse'\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// When a category has set `isExternalResource` to `true`, we\n\t\t\t// don't need to check for allowed mime types, as they are used\n\t\t\t// for restricting uploads for this media type and not for\n\t\t\t// inserting media from external sources.\n\t\t\tif ( category.isExternalResource ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn Object.values( allowedMimeTypes ).some( ( mimeType ) =>\n\t\t\t\tmimeType.startsWith( `${ category.mediaType }/` )\n\t\t\t);\n\t\t} );\n\t}, [\n\t\tinserterMediaCategories,\n\t\tallowedMimeTypes,\n\t\tenableOpenverseMediaCategory,\n\t] );\n\treturn allowedCategories;\n}\n\nexport function useMediaCategories( rootClientId ) {\n\tconst [ categories, setCategories ] = useState( [] );\n\tconst { canInsertImage, canInsertVideo, canInsertAudio } = useSelect(\n\t\t( select ) => {\n\t\t\tconst { canInsertBlockType } = select( blockEditorStore );\n\t\t\treturn {\n\t\t\t\tcanInsertImage: canInsertBlockType(\n\t\t\t\t\t'core/image',\n\t\t\t\t\trootClientId\n\t\t\t\t),\n\t\t\t\tcanInsertVideo: canInsertBlockType(\n\t\t\t\t\t'core/video',\n\t\t\t\t\trootClientId\n\t\t\t\t),\n\t\t\t\tcanInsertAudio: canInsertBlockType(\n\t\t\t\t\t'core/audio',\n\t\t\t\t\trootClientId\n\t\t\t\t),\n\t\t\t};\n\t\t},\n\t\t[ rootClientId ]\n\t);\n\tconst inserterMediaCategories = useInserterMediaCategories();\n\tuseEffect( () => {\n\t\t( async () => {\n\t\t\tconst _categories = [];\n\t\t\t// If `inserterMediaCategories` is not defined in\n\t\t\t// block editor settings, do not show any media categories.\n\t\t\tif ( ! inserterMediaCategories ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Loop through categories to check if they have at least one media item.\n\t\t\tconst categoriesHaveMedia = new Map(\n\t\t\t\tawait Promise.all(\n\t\t\t\t\tinserterMediaCategories.map( async ( category ) => {\n\t\t\t\t\t\t// Some sources are external and we don't need to make a request.\n\t\t\t\t\t\tif ( category.isExternalResource ) {\n\t\t\t\t\t\t\treturn [ category.name, true ];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst results = await category.fetch( { per_page: 1 } );\n\t\t\t\t\t\treturn [ category.name, !! results.length ];\n\t\t\t\t\t} )\n\t\t\t\t)\n\t\t\t);\n\t\t\t// We need to filter out categories that don't have any media items or\n\t\t\t// whose corresponding block type is not allowed to be inserted, based\n\t\t\t// on the category's `mediaType`.\n\t\t\tconst canInsertMediaType = {\n\t\t\t\timage: canInsertImage,\n\t\t\t\tvideo: canInsertVideo,\n\t\t\t\taudio: canInsertAudio,\n\t\t\t};\n\t\t\tinserterMediaCategories.forEach( ( category ) => {\n\t\t\t\tif (\n\t\t\t\t\tcanInsertMediaType[ category.mediaType ] &&\n\t\t\t\t\tcategoriesHaveMedia.get( category.name )\n\t\t\t\t) {\n\t\t\t\t\t_categories.push( category );\n\t\t\t\t}\n\t\t\t} );\n\t\t\tif ( !! _categories.length ) {\n\t\t\t\tsetCategories( _categories );\n\t\t\t}\n\t\t} )();\n\t}, [\n\t\tcanInsertImage,\n\t\tcanInsertVideo,\n\t\tcanInsertAudio,\n\t\tinserterMediaCategories,\n\t] );\n\treturn categories;\n}\n"]}