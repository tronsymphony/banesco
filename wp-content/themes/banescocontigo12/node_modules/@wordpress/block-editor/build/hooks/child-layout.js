"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChildLayoutEdit = ChildLayoutEdit;
exports.childLayoutOrientation = childLayoutOrientation;
exports.hasChildLayoutSupport = hasChildLayoutSupport;
exports.hasChildLayoutValue = hasChildLayoutValue;
exports.resetChildLayout = resetChildLayout;
exports.useIsChildLayoutDisabled = useIsChildLayoutDisabled;

var _element = require("@wordpress/element");

var _components = require("@wordpress/components");

var _i18n = require("@wordpress/i18n");

var _useSetting = _interopRequireDefault(require("../components/use-setting"));

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
function helpText(selfStretch, parentLayout) {
  const {
    orientation = 'horizontal'
  } = parentLayout;

  if (selfStretch === 'fill') {
    return (0, _i18n.__)('Stretch to fill available space.');
  }

  if (selfStretch === 'fixed') {
    if (orientation === 'horizontal') {
      return (0, _i18n.__)('Specify a fixed width.');
    }

    return (0, _i18n.__)('Specify a fixed height.');
  }

  return (0, _i18n.__)('Fit contents.');
}
/**
 * Inspector controls containing the child layout related configuration.
 *
 * @param {Object} props                        Block props.
 * @param {Object} props.attributes             Block attributes.
 * @param {Object} props.setAttributes          Function to set block attributes.
 * @param {Object} props.__unstableParentLayout
 *
 * @return {WPElement} child layout edit element.
 */


function ChildLayoutEdit(_ref) {
  let {
    attributes,
    setAttributes,
    __unstableParentLayout: parentLayout
  } = _ref;
  const {
    style = {}
  } = attributes;
  const {
    layout: childLayout = {}
  } = style;
  const {
    selfStretch,
    flexSize
  } = childLayout;
  (0, _element.useEffect)(() => {
    if (selfStretch === 'fixed' && !flexSize) {
      setAttributes({
        style: { ...style,
          layout: { ...childLayout,
            selfStretch: 'fit'
          }
        }
      });
    }
  }, []);
  return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_components.__experimentalToggleGroupControl, {
    __nextHasNoMarginBottom: true,
    size: '__unstable-large',
    label: childLayoutOrientation(parentLayout),
    value: selfStretch || 'fit',
    help: helpText(selfStretch, parentLayout),
    onChange: value => {
      const newFlexSize = value !== 'fixed' ? null : flexSize;
      setAttributes({
        style: { ...style,
          layout: { ...childLayout,
            selfStretch: value,
            flexSize: newFlexSize
          }
        }
      });
    },
    isBlock: true
  }, (0, _element.createElement)(_components.__experimentalToggleGroupControlOption, {
    key: 'fit',
    value: 'fit',
    label: (0, _i18n.__)('Fit')
  }), (0, _element.createElement)(_components.__experimentalToggleGroupControlOption, {
    key: 'fill',
    value: 'fill',
    label: (0, _i18n.__)('Fill')
  }), (0, _element.createElement)(_components.__experimentalToggleGroupControlOption, {
    key: 'fixed',
    value: 'fixed',
    label: (0, _i18n.__)('Fixed')
  })), selfStretch === 'fixed' && (0, _element.createElement)(_components.__experimentalUnitControl, {
    size: '__unstable-large',
    onChange: value => {
      setAttributes({
        style: { ...style,
          layout: { ...childLayout,
            flexSize: value
          }
        }
      });
    },
    value: flexSize
  }));
}
/**
 * Determines if there is child layout support.
 *
 * @param {Object} props                        Block Props object.
 * @param {Object} props.__unstableParentLayout Parent layout.
 *
 * @return {boolean}     Whether there is support.
 */


function hasChildLayoutSupport(_ref2) {
  let {
    __unstableParentLayout: parentLayout = {}
  } = _ref2;
  const {
    type: parentLayoutType = 'default',
    default: {
      type: defaultParentLayoutType = 'default'
    } = {},
    allowSizingOnChildren = false
  } = parentLayout;
  const support = (defaultParentLayoutType === 'flex' || parentLayoutType === 'flex') && allowSizingOnChildren;
  return support;
}
/**
 * Checks if there is a current value in the child layout attributes.
 *
 * @param {Object} props Block props.
 * @return {boolean}      Whether or not the block has a child layout value set.
 */


function hasChildLayoutValue(props) {
  var _props$attributes$sty;

  return ((_props$attributes$sty = props.attributes.style) === null || _props$attributes$sty === void 0 ? void 0 : _props$attributes$sty.layout) !== undefined;
}
/**
 * Resets the child layout attribute. This can be used when disabling
 * child layout controls for a block via a progressive discovery panel.
 *
 * @param {Object} props               Block props.
 * @param {Object} props.attributes    Block attributes.
 * @param {Object} props.setAttributes Function to set block attributes.
 */


function resetChildLayout(_ref3) {
  let {
    attributes = {},
    setAttributes
  } = _ref3;
  const {
    style
  } = attributes;
  setAttributes({
    style: { ...style,
      layout: undefined
    }
  });
}
/**
 * Custom hook that checks if child layout settings have been disabled.
 *
 * @param {Object} props Block props.
 *
 * @return {boolean}     Whether the child layout setting is disabled.
 */


function useIsChildLayoutDisabled(props) {
  const isDisabled = !(0, _useSetting.default)('layout');
  return !hasChildLayoutSupport(props) || isDisabled;
}

function childLayoutOrientation(parentLayout) {
  const {
    orientation = 'horizontal'
  } = parentLayout;
  return orientation === 'horizontal' ? (0, _i18n.__)('Width') : (0, _i18n.__)('Height');
}
//# sourceMappingURL=child-layout.js.map